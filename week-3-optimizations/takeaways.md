* memoization / caching
* dynamic programming
  * break a big problem down into small subproblems
  * recognize overlapping subproblems and avoid repeated work
  * store solutions to subproblems for easy lookup later
* ratcheting
* data structures
  * usually involve tradeoffs
  * if you want to optimize for time, setting aside a little extra space for an efficient data structure is a great way to do it
* we can optimize for other things outside of time and space
  * time spent writing a program
  * productivity
    * programmer productivity is often the bottleneck in the real world
  * readability
  * flexibility
* top-down vs. bottom-up
  * top-down generally implies recursion
  * bottom-up => iterative
